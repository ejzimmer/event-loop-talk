<template id="task-source">
  <style>
      :host {
        display: flex;
        --diameter: 9vmin;
        cursor: pointer;
      }
      .container {
        width: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      .thread {
        --diameter: calc(4.5vmin - 13px);
        display: flex;
        flex-wrap: wrap;
        position: absolute;
        top: 100%;
        width: calc(var(--diameter) + 50px);
      }


      .timer {
				--colour: white;
				border: 4px solid var(--colour);
				border-radius: 50%;
				width: var(--diameter);
				height: var(--diameter);
				position: relative;
				flex-shrink: 0;
        transition: transform steps(12, end);
			}
			.timer::after {
				content: '';
				border: 2px solid var(--colour);
				height: calc(var(--diameter) / 2 - 4px);
				position: absolute;
				left: 50%;
      }
      .timer.go {
        transform: rotate(1turn);
      }

      .html {
        display: flex;
      }
      .html::after {
        content: '<script>\A...</script>';
        font-family: 'Courier New', Courier, monospace;
        font-weight: bold;
        font-size: 2vw;
        margin: auto;
      }

      .network {
        width: var(--diameter);
        height: var(--diameter);
        margin: auto;
        background: repeating-radial-gradient(circle at bottom left, white, white 9%, transparent 9%, transparent 18%);
        border-top-right-radius: 100%;
        transform-origin: bottom left;
        transform:  translateX(50%) rotate(-.125turn);
        position: relative;
      }
      .network::after {
        content: '';
        display: block;
        width: 18%;
        height: 18%;
        border-radius: 50%;
        background-color: white;
        position: absolute;
        left: -4.5%;
        bottom: -4.5%;
      }
      .thread .network {
        animation: wifi 3s infinite steps(3);
      }
      @keyframes wifi {
        from {
          background: none;
        }
        33% { 
          background: radial-gradient(circle at bottom left, transparent, transparent 18%, white 18%, white 27%, transparent 27%);
        }
        66% {
          background: radial-gradient(circle at bottom left, transparent, transparent 36%, white 36%, white 45%, transparent 45%);
        }
        to {
          background: radial-gradient(circle at bottom left, transparent, transparent 54%, white 54%, white 63%, transparent 63%);
        }
      }
      .network:hover {
        transform:  translateX(50%) rotate(-.125turn);
      }


      .drive {
        width: var(--diameter);
        height: calc(var(--diameter) * 1.4);
        border: 2px solid white;
        border-radius: 4px;
        position: relative;
        background: 
          radial-gradient(circle at 50% 40%, transparent, transparent 5%, white 5%, white 10%, goldenrod 10%, grey 50%, white 50%, white calc(50% + 1px), transparent 20%),
          radial-gradient(circle at 30% 75%, #334 20%, white calc(20% + 4px), transparent calc(20% + 4px));
      }
      .drive .arm {
        border: 8px solid transparent;
        border-bottom-color: white;
        box-sizing: border-box;
        width: 8px;
        position: absolute;
        bottom: 20%;
        left: calc(30% - 8px);
        transform-origin: bottom;
        transform: rotate(.1turn);
        animation: read-drive 2s infinite alternate linear;
        animation-play-state: paused;
      }
      @keyframes read-drive {
        from { transform: rotate(.09turn); }
        to { transform: rotate(.18turn); }
      }

      .promise {
        width: var(--diameter);
        height: var(--diameter);
        background-color: #f7df1e;
        position: relative;
      }
      .promise::after {
        content: 'then';
        position: absolute;
        right: 5px;
        bottom: 5px;
        color: black;
        font-size: 3vmin;
      }

      .animation {
        width: var(--diameter);
        height: var(--diameter);
        background-image: url('css/cat.png');
        background-size: contain;
      }
      .animation.running {
        background-image: url('css/cat.gif');
      }

      .immediate::after {
        content: '!';
        font-weight: bold;
        color: white;
        font-size: 4em;
        padding: 0 10px;
        font-family: serif;
      }

      .next-tick {
        width: var(--diameter);
        height: var(--diameter);
        display: flex;
        border-radius: 50%;
      }

      .next-tick::after {
        content: '';
        display: block;
        border: 10px solid green;
        width: calc(var(--diameter) * .6);
        height: calc(var(--diameter) * .3);
        border-top-style: none;
        border-right-style: none;
        transform: rotate(-.125turn);
        margin: auto;
      }

      .postmessage {
        width: var(--diameter);
        height: calc(var(--diameter) / 1.4);
        margin-top: calc(var(--diameter) * .3);
        border: 4px solid white;
        position: relative;
      }

      .postmessage::after {
        content: '';
        display: block;
        border: inherit;
        width: calc(var(--diameter) / 1.41 - 1.5px);
        height: calc(var(--diameter) / 1.41 - 1.5px);
        transform-origin: top left;
        transform: rotate(-.125turn);
        position: absolute;
        left: -2.5px;
        top: -.5px;
        border-top: transparent;
        border-right: transparent;
        border-bottom-left-radius: 5px;
      }
  </style>
  <div class="container"></div>
</template>
<script>
  const taskSourceDocument = document.currentScript.ownerDocument;
  class TaskSource extends HTMLElement {
    constructor() {
      super();

      this.shadow = this.attachShadow({ mode: 'closed' });
      const content = taskSourceDocument.getElementById('task-source').content.cloneNode(true);
      this.shadow.appendChild(content);

      this.type = this.attributes.type.value;
      this.container = this.shadow.querySelector('.container');

      if (this.type === 'browser') {
        const browser = document.createElement('browser-window');
        this.container.appendChild(browser);
      } else {
        this.source = document.createElement('div');
        this.source.classList.add(this.type);
        this.container.appendChild(this.source);

        this.thread = document.createElement('div');
        this.thread.classList.add('thread');
        this.container.appendChild(this.thread);

        if (this.type === 'drive') {
          this.arm = document.createElement('div');
          this.arm.classList.add('arm');
          this.source.appendChild(this.arm);
        }
      }
    }

    connectedCallback() {
      if (this.type === 'drive') {
        const driveHeight = this.source.getBoundingClientRect().height;
        const armHeight = driveHeight * 0.35;
        this.arm.style.height = armHeight;
        this.arm.style.borderBottomWidth = `${armHeight}px`;
      }

      const syncTasks = ['html', 'promise', 'animation', 'immediate', 'next-tick', 'postmessage'];
      if (syncTasks.includes(this.type)) {
        this.container.addEventListener('click', () => {
          this.addTask();
        });
      } else if (this.source) {
        this.source.addEventListener('click', () => {
          this.startAsyncTask();
        });
      }

      document.body.addEventListener('keydown', (event) => {
        if (event.key === 'PageDown') {
          location.href = '/#/7';
        }
      }, { once: true })
    }

    startAsyncTask() {
      const asyncTask = document.createElement('div');
      asyncTask.classList.add(this.type);
      this.thread.appendChild(asyncTask);

      requestAnimationFrame(() => asyncTask.classList.add('go'));

      if (this.type === 'timer') {
        asyncTask.style.transitionDuration = `${this.getRandomTime()}ms`;
        asyncTask.addEventListener('transitionend', () => {
          this.addTask();
          asyncTask.remove();
        });
      } else if (this.type === 'drive') {
        const isPlaying = this.arm.style.animationPlayState === 'running';

        if (!isPlaying) {
          this.arm.style.animationPlayState = 'running';
          this.finishDriveTask();
        }
      } else {
        this.finishTask(asyncTask);
      }
    }

    finishTask(task, time = this.getRandomTime()) {
      setTimeout(() => {
        this.addTask();
        task.remove();
      }, time);
    }

    finishDriveTask() {
      setTimeout(() => {
        const driveTasks = this.shadow.querySelectorAll('.thread .drive');
        const currentTask = driveTasks[0];
        this.finishTask(currentTask, 0);

        if (driveTasks.length > 1) {
          const nextTask = driveTasks[1];
          this.finishDriveTask();
        } else {
          this.arm.style.animationPlayState = 'paused';
        }
      }, this.getRandomTime());
    }

    getRandomTime() {
      return (Math.random() * 7000) + 3000;
    }

    addTask() {
      const type = this.type === 'promise' ? 'microtask' : this.type;
      document.body.dispatchEvent(new CustomEvent('task', { detail: type }));     
    }

    run() {
      this.source.classList.add('running');
    }
    stop() {
      this.source.classList.remove('running');
    }

    hasTasksWaiting() {
      if (this.thread) {
        return !!this.thread.children.length;
      }
    }
  }
  customElements.define('task-source', TaskSource);
</script>

