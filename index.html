<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>Fun Adventures with the Event Loop</title>

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap"
      rel="stylesheet"
    />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Great+Vibes&family=Raleway&display=swap"
      rel="stylesheet"
    />

    <link rel="stylesheet" href="css/reveal.css" />
    <link rel="stylesheet" href="css/loops.css" />
    <link rel="stylesheet" href="css/common.css" />

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css" />

    <script src="js/reveal.js"></script>

    <script>
      const isNextSlide = (key) =>
        key === "PageDown" || key === "ArrowRight" || key === " "
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <div class="mask">
            <svg class="title" viewBox="0 0 100 50" style="width: 80%">
              <path
                id="curve"
                d="M 10 50 a 40 40 0 0 1 80 0"
                fill="transparent"
              />
              <text font-family="Great Vibes">
                <textPath font-size=".8em" textLength="125" xlink:href="#curve">
                  Fun Adventures with
                </textPath>
              </text>
            </svg>
          </div>
          <img
            src="css/dinosaur-head.png"
            style="
              position: absolute;
              transform: scale(0.3) translate(-160%, -200%);
            "
          />
          <h1 style="position: relative">The Event Loop</h1>
          <div class="twitter">@erinjzimmer</div>
        </section>
        <section data-background-image="css/perth-concert-hall.JPG">
          <div class="about-me">
            <ul
              style="
                display: block;
                align-self: center;
                margin: 15px 40px;
                padding: 0.5em;
              "
            >
              <li class="fragment" data-fragment-index="1">Erin Zimmer</li>
              <li class="fragment">twitter.com/ErinJZimmer</li>
              <li class="fragment" style="margin-bottom: 0">
                event-loop.ez.codes
              </li>
            </ul>
            <div class="fragment cogent-logo" data-fragment-index="2">
              <img width="200px" src="css/CO-Cogent-secondary-watermelon.png" />
            </div>
          </div>
        </section>
        <section>
          <h2 style="font-size: 3.5em">What actually is the Event Loop?</h2>
        </section>
        <section data-state="web-apis">
          <fieldset class="browser-internals">
            <legend>The Browser</legend>
            <div class="browser-bits">
              <img
                id="engine"
                src="css/JavaScript-logo.png"
                class="fragment"
                style="margin-left: 0"
              />
              <task-source type="network" class="fragment"></task-source>
              <task-source type="timer" class="fragment"></task-source>
              <task-source type="drive" class="fragment"></task-source>
              <img
                src="css/mouse-pointer.svg"
                class="fragment"
                style="margin: 0.75em"
              />
              <div class="html fragment"></div>
              <div id="web-apis" class="fragment">Web APIs</div>
            </div>
          </fieldset>
          <script>
            let lastItem
            function highlightWebApis(event) {
              if (
                lastItem.classList.contains("current-fragment") &&
                isNextSlide(event.key)
              ) {
                event.stopPropagation()
                document
                  .querySelector(".browser-internals")
                  .classList.add("web-apis")
                document.body.removeEventListener("keydown", highlightWebApis)
              }
            }
            Reveal.addEventListener("web-apis", () => {
              lastItem = document.querySelector(
                ".browser-bits div.html.fragment"
              )
              document.body.addEventListener("keydown", highlightWebApis)
            })
          </script>
        </section>
        <section data-state="js-engine">
          <fieldset class="browser-internals engine">
            <legend>The Browser</legend>
            <div class="browser-bits">
              <img
                id="engine"
                src="css/JavaScript-logo.png"
                style="margin-left: 0"
              />
              <task-source type="network"></task-source>
              <task-source type="timer"></task-source>
              <task-source type="drive"></task-source>
              <img src="css/mouse-pointer.svg" style="margin: 0.75em" />
              <div class="html"></div>
              <div id="engines" class="fragment">JavaScript Engine</div>
            </div>
          </fieldset>
          <script>
            function highlightJSEngine(event) {
              if (isNextSlide(event.key)) {
                event.stopPropagation()
                document
                  .querySelector(".browser-internals.engine #engine")
                  .classList.add("highlighted")
                document.body.removeEventListener("keydown", highlightJSEngine)
              }
            }
            Reveal.addEventListener("js-engine", () => {
              document.body.addEventListener("keydown", highlightJSEngine)
            })
          </script>
        </section>
        <section>
          <div class="engine-logos">
            <img class="fragment" src="css/v8-logo.png" />
            <img
              class="fragment"
              src="css/edge-logo.png"
              style="transform: scale(0.6)"
            />
            <img class="fragment" src="css/squirrelfish.png" />
          </div>
          <img
            class="fragment"
            src="css/spider-monkey.jpg"
            style="width: 80%"
          />
        </section>
        <section>
          <div class="centred">
            <div class="inverse big-text">Web APIs</div>
            <div class="arrow-down">^</div>
            <div class="uninverse big-text">JavaScript Engine</div>
          </div>
        </section>
        <section>
          <pre><code data-noescape class="js" style="font-size: 4em; overflow: hidden">
while (true) {
 <span class="variable-name">task</span> = taskQueue.pop();
 execute(<span class="variable-name">task</span>);
}
					</code></pre>
        </section>
        <section>
          <div class="list-and-image">
            <ul>
              <li class="fragment">What's a task?</li>
              <li class="fragment">What's a task&nbsp;queue?</li>
              <li class="fragment">
                How do tasks<br />get in the task&nbsp;queue?
              </li>
            </ul>
            <img src="css/Philosoraptor.jpg" />
          </div>
        </section>
        <section>
          <div class="columns">
            <pre><code>
<script>
 const intrepidAdventurers = [
  'Little Foot',
  'Cera',
  'Ducky',
  'Petrie',
  'Spike'
 ];

 function rawr() {
  console.log('rawr!')
 }

 intrepidAdventurers.forEach(rawr);
</script>
					</code></pre>
            <div class="arrow-right fragment" data-fragment-index="1">^</div>
            <div class="task fragment" data-fragment-index="1"></div>
          </div>
        </section>
        <section>
          <iframe
            style="overflow: hidden"
            src="http://localhost:3000/parser-only"
          ></iframe>
        </section>
        <section>
          <h2>
            <div style="font-size: 0.9em">
              JavaScript, why are you like that?
            </div>
          </h2>
        </section>
        <section>
          <h2>JavaScript is single-threaded</h2>
          <div class="notes">
            - But remember, the JS engine is only one part of the browser
          </div>
        </section>
        <section>
          <h2><i>Browsers</i> are multi-threaded</h2>
          <div class="notes">
            As well as running your JavaScript, a browser could be - keeping
            track of mouse and keyboard events - making network requests -
            handling timers - disk operations And any of these things could be
            generating tasks, via callbacks
          </div>
        </section>
        <section>
          <fieldset class="browser-internals">
            <legend>The Browser</legend>
            <div class="browser-bits">
              <img
                id="engine"
                src="css/JavaScript-logo.png"
                style="margin-left: 0"
              />
              <task-source type="network"></task-source>
              <task-source type="timer"></task-source>
              <task-source type="drive"></task-source>
              <img src="css/mouse-pointer.svg" style="margin: 0.75em" />
              <div class="html"></div>
            </div>
          </fieldset>
        </section>
        <section>
          <div class="notes">
            In fact, this idea is the very heart of the asynchronous programming
            we all know and love so much
          </div>
          <pre><code style="font-size: 3em">setTimeout(myCallbackFunction, 3000);</code></pre>
        </section>
        <section>
          <div style="display: flex; flex-direction: column; margin: 1em">
            <div
              class="quote fragment"
              style="
                text-align: left;
                margin-bottom: 2em;
                --quote-colour: var(--green);
              "
            >
              Hey WebAPIs! Could you wait 3 seconds and then run my callback
              function?
            </div>
            <div
              class="quote fragment"
              style="
                text-align: left;
                align-self: flex-end;
                --quote-colour: var(--pink);
              "
            >
              No worries! You keep doing your thing, I'll take care of this.
            </div>
          </div>
        </section>
        <section>
          <iframe src="http://localhost:3000/simple"></iframe>
        </section>
        <section>
          <pre><code data-noescape class="js" style="font-size: 4em; overflow: hidden">
while (true) {
 <span class="variable-name">task</span> = taskQueue.pop();
 execute(<span class="variable-name">task</span>);
}
					</code></pre>
          <div class="notes">
            So that's basically how tasks and task queues work. Of course, in
            real life, it's a bit more complicated than that
          </div>
        </section>
        <section data-background-image="css/mario.jpg">
          <h2 class="heading-card">The Rendering Pipeline</h2>
        </section>
        <section>
          <iframe src="http://localhost:3000/rendering-pipeline"></iframe>
        </section>
        <section class="center">
          <img src="css/dino-jaw.gif" class="stretch border" />
          <div class="notes">
            Long running tasks will cause your browser to start dropping frames
            and, much like this cat, your app just won't run right
          </div>
        </section>
        <section class="center">
          <pre><code style="font-size: 3em; overflow: hidden">function repeat(reps, action) {
 for (let i = 0; i < reps; i++) {
   action();
 }
}					</code></pre>
        </section>
        <section class="center">
          <pre><code style="font-size: 3em; overflow: hidden">function repeat(reps, action) {
 action();
 if (--reps) {
  setTimeout(() => repeat(reps, action));
 }
}					</code></pre>
        </section>
        <section>
          <pre><code style="font-size: 3em; overflow: hidden" class="js">
/*  job.js  */
onmessage = function(e) {
 for (let i = 0; i < e.data.reps; i++) {
  e.data.action();
 }
}</code></pre>
          <pre><code style="font-size: 3em; overflow: hidden" class="js fragment">
/*  app.js  */
const worker = new Worker('job.js');
worker.postMessage(action, reps);
					</code></pre>
          <img src="css/Yoshi_Happy.png" class="yoshi fragment" />
        </section>
        <section>
          <pre><code data-noescape class="js" style="font-size: 3.7em; overflow: hidden">
while (true) {
 <span class="variable-name">task</span> = taskQueue.pop();
 execute(<span class="variable-name">task</span>);

 if (isRepaintTime()) repaint();
}
					</code></pre>
        </section>
        <section>
          <div class="spec-text" style="font-size: 2.5em">
            An <u>event loop</u> has one or more <b>task queues.</b>
          </div>
        </section>
        <section>
          <pre><code>
bool did_work = delegate->DoWork();
if (!keep_running_)
 break;
did_work |= delegate->DoDelayedWork(&delayed_work_time_);
if (!keep_running_)
 break;
if (did_work)
 continue;
did_work = delegate->DoIdleWork();
if (!keep_running_)
 break;
					</code></pre>
        </section>
        <section data-background-image="css/dinosaur-queues.jpg">
          <h2 class="heading-card">Multiple task queues</h2>
        </section>
        <section>
          <iframe src="http://localhost:3000/multiple-queues"></iframe>
        </section>
        <section>
          <div style="font-size: 1.5em">
            <ul>
              <li class="fragment">Queues can be executed in any order</li>
              <li class="fragment">
                Tasks in the same queue must be executed in the order they
                arrived
              </li>
              <li class="fragment">
                Tasks from the same source<br />
                must go in the same queue
              </li>
            </ul>
          </div>
        </section>
        <section>
          <pre><code data-noescape class="js" style="font-size: 3.7em' overflow: hidden">
while (true) {
 <span class="variable-name">queue</span> = getNextQueue();
 <span class="variable-name">task</span> = <span class="variable-name">queue</span>.pop();
 execute(<span class="variable-name">task</span>);

 if (isRepaintTime()) repaint();
}
					</code></pre>
        </section>
        <section data-background-image="css/littlefoot-and-mum.jpg">
          <h2 class="heading-card" style="position: relative; top: 20px">
            Microtasks
          </h2>
        </section>
        <section>
          <div style="font-size: 3.8em">
            A task that happens between a task and rendering
          </div>
          <div class="notes">
            Between one task and the next, or between task and rendering
          </div>
        </section>
        <section>
          <pre><code>
const observer = new MutationObserver(callback);
const myElement = document.getElementById('stegosaurus');
observer.observe(myElement, ({ subtree: true }));
					</code></pre>
          <div class="notes">
            Potentially lots of things happening Changes to DOM, want to run
            things related to changing DOM before window renders again
          </div>
        </section>
        <section>
          <pre><code class="js" style="overflow: hidden">
const myPromise = new Promise((resolve, reject) => { ... });
myPromise.then(callback).catch(errorCallback);
					</code></pre>
          <div class="notes">
            Performance reasons Esp catch -> want error handling to happen after
            stuff, but before anything else
          </div>
        </section>
        <section>
          <pre><code>
window.queueMicrotask(callback);
					</code></pre>
          <div class="notes">
            generally intended for people writing frameworks
          </div>
        </section>
        <section>
          <iframe src="http://localhost:3000/microtasks"></iframe>
        </section>
        <section data-background-image="css/dinos-fightin.jpg">
          <div style="display: flex">
            <h2 class="heading-card" style="display: block; margin: auto">
              <a href="infinite-timeouts.html">Tasks</a>
              <div style="margin: 10px">vs</div>
              <a href="infinite-promises.html" target="_blank" rel="noopener"
                >Microtasks</a
              >
            </h2>
          </div>
        </section>
        <section>
          <iframe src="http://localhost:3000/microtasks"></iframe>
        </section>
        <section>
          <pre><code data-noescape class="js" style="font-size: 3.5em; overflow: hidden">
while (true) {
 <span class="variable-name">queue</span> = getNextQueue();
 <span class="variable-name">task</span> = <span class="variable-name">queue</span>.pop();
 execute(<span class="variable-name">task</span>);

 while (<span class="variable-name">microtaskQueue</span>.hasTasks())
  doMicrotask();

 if (isRepaintTime()) repaint();
}
					</code></pre>
        </section>
        <section data-background-image="css/ducky-walking.gif">
          <h2 class="heading-card reverse" style="display: block">
            Animation Frame Callback Queue
          </h2>
        </section>
        <section>
          <pre><code style="text-align: center; font-size: 3.7em; overflow: hidden">
requestAnimationFrame(callback);
					</code></pre>
        </section>
        <section>
          <iframe
            style="border: none; overflow: hidden"
            src="single-box-animation.html"
          ></iframe>
          <div class="notes">
            Why would we want to do this? Well, imagine we wanted to make a nice
            animation of a box moving along a path.
          </div>
        </section>
        <section>
          <pre
            style="font-size: 1.3em"
          ><code>while (box.style.right < screen.width) {
 const elapsedTime = Date.now() - startTime;
 box.style.left = calculateX(elapsedTime);
 box.style.top = calculateY(elapsedTime)
}

					</code></pre>
        </section>
        <section data-transition="fade-in">
          <div
            style="
              width: 100px;
              height: 100px;
              background-color: rgb(var(--green));
              position: fixed;
              right: -50px;
            "
          ></div>
          <div class="notes">
            If you did that, what you would get is this...
          </div>
        </section>
        <section>
          <pre
            style="font-size: 1.3em"
          ><code class="js" data-noescape>function move() {
 const elapsedTime = Date.now() - startTime;
 box.style.left = calculateX(elapsedTime);
 box.style.top = calculateY(elapsedTime);
 if (box.style.right < screen.width)
  <span style="color: rgb(var(--green))">setTimeout(move);</span>
}
					</code></pre>
        </section>
        <section>
          <iframe
            id="timeout-animations"
            style="width: 100%; min-height: 40vh; border: none"
            src="http://localhost:3000/timeout-animation"
          ></iframe>
        </section>
        <section data-state="addTasks">
          <div style="display: flex; align-items: center; margin-top: 200px">
            <task-queue
              id="too-many-tasks"
              style="--queue-width: 200px; margin: auto"
            ></task-queue>
          </div>
          <script>
            Reveal.addEventListener("addTasks", function () {
              const tooManyTasks = document.getElementById("too-many-tasks")
              for (let i = 0; i < 12; i++) {
                if (!(i % 4)) tooManyTasks.addTask("necessary")
                else tooManyTasks.addTask("unnecessary")
              }
            })
          </script>
        </section>
        <section>
          <pre
            style="font-size: 1.3em"
          ><code class="js" data-noescape>function move() {
 const elapsedTime = Date.now() - startTime;
 box.style.left = calculateX(elapsedTime);
 box.style.top = calculateY(elapsedTime);
 if (x < screen.width)
  <span style="color: rgb(var(--green))">requestAnimationFrame(move);</span>
 }
}</code></pre>
        </section>
        <section>
          <iframe src="http://localhost:3000/animation"></iframe>
        </section>
        <section>
          <iframe
            style="width: 100%; min-height: 80vh; border: none"
            src="animations.html"
          ></iframe>
        </section>
        <section>
          <img
            src="css/caniuse-requestAnimationFrame.png"
            class="stretch shadow"
          />
        </section>
        <section>
          <pre><code data-noescape class="js" style="font-size: 2.6em; overflow: hidden">
while (true) {
 <span class="variable-name">queue</span> = getNextQueue();
 <span class="variable-name">task</span> = <span class="variable-name">queue</span>.pop();
 execute(<span class="variable-name">task</span>);

 while (<span class="variable-name">microtaskQueue</span>.hasTasks()) 
  doMicrotask();

 if (isRepaintTime()) {
  <span class="variable-name">animationTasks</span> = <span class="variable-name">animationQueue</span>.copyTasks();
  for (<span class="variable-name">task</span> in <span class="variable-name">animationTasks</span>) 
   doAnimationTask(<span class="variable-name">task</span>);
		
  repaint();
 }
}
					</code></pre>
        </section>

        <section>
          <ul>
            <li class="fragment">Don't block rendering</li>
            <li class="fragment">Promises beat tasks</li>
            <li class="fragment">Animate with requestAnimationFrame</li>
          </ul>
        </section>
        <section>
          <pre
            style="margin-top: -150px; font-size: 2em"
          ><code style="padding-left: 0" class="js">setTimeout(fn, 0)</code></pre>
        </section>
        <section data-background-image="css/jurassic-park-raptors.jpg">
          <h2 class="heading-card fragment" data-fragment-index="1">
            Thanks! (rawr)
          </h2>
          <div
            class="twitter fragment"
            style="opacity: 0.9"
            data-fragment-index="1"
          >
            @erinjzimmer
          </div>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>

    <script>
      // More info about config & dependencies:
      // - https://github.com/hakimel/reveal.js#configuration
      // - https://github.com/hakimel/reveal.js#dependencies
      Reveal.initialize({
        controls: false,
        progress: false,
        history: true,
        dependencies: [
          { src: "plugin/markdown/marked.js" },
          { src: "plugin/markdown/markdown.js" },
          { src: "plugin/notes/notes.js", async: true },
          {
            src: "plugin/highlight/highlight.js",
            async: true,
            callback: function () {
              hljs.initHighlightingOnLoad()
            },
          },
        ],
      })
    </script>

    <template id="task-source">
      <style>
        :host {
          --width: 8em;
          --thickness: 12px;
          cursor: pointer;
        }

        .thread {
          display: flex;
          flex-wrap: wrap;
          justify-content: flex-start;
          width: calc(var(--width) + var(--thickness) * 2);
          position: absolute;
          top: 100%;
        }
        .thread-item {
          --size: calc(var(--width) / 2 + var(--thickness));
          width: var(--size);
          height: var(--size);
        }
        .shrinker {
          transform: scale(0.4);
          transform-origin: 20% top;
        }

        .html {
          display: flex;
          width: 10em;
        }
        .html::after {
          content: "<script>\A...\A</script>";
          font-family: "Courier New", Courier, monospace;
          font-weight: bold;
          font-size: 3.35vw;
          margin: auto;
        }

        .browser {
          background-image: url("css/mouse-pointer.svg");
          background-size: contain;
          background-repeat: no-repeat;
          height: calc(var(--width) / 1.16);
          width: calc(var(--width) / 2);
        }

        .timer {
          --colour: white;
          border: var(--thickness) solid var(--colour);
          border-radius: 50%;
          width: var(--width);
          height: var(--width);
          position: relative;
          flex-shrink: 0;
          transition: transform steps(12, end);
        }
        .timer::after {
          content: "";
          border: calc(var(--thickness) / 2) solid var(--colour);
          background-color: var(--colour);
          height: calc((var(--width) - var(--thickness)) / 2);
          position: absolute;
          left: calc(50% - var(--thickness) / 2);
        }
        .timer.go {
          transform: rotate(1turn);
        }

        .network {
          width: var(--width);
          height: var(--width);
          margin: auto;
          background: repeating-radial-gradient(
            circle at bottom left,
            white,
            white 9%,
            transparent 9%,
            transparent 18%
          );
          border-top-right-radius: 100%;
          transform-origin: bottom left;
          transform: translateX(50%) rotate(-0.125turn);
          position: relative;
        }
        .network::after {
          content: "";
          display: block;
          width: 18%;
          height: 18%;
          border-radius: 50%;
          background-color: white;
          position: absolute;
          left: -4.5%;
          bottom: -4.5%;
        }
        .thread .network {
          animation: wifi 3s infinite steps(3);
        }
        @keyframes wifi {
          from {
            background: none;
          }
          33% {
            background: radial-gradient(
              circle at bottom left,
              transparent,
              transparent 18%,
              white 18%,
              white 27%,
              transparent 27%
            );
          }
          66% {
            background: radial-gradient(
              circle at bottom left,
              transparent,
              transparent 36%,
              white 36%,
              white 45%,
              transparent 45%
            );
          }
          to {
            background: radial-gradient(
              circle at bottom left,
              transparent,
              transparent 54%,
              white 54%,
              white 63%,
              transparent 63%
            );
          }
        }
        .network:hover {
          transform: translateX(50%) rotate(-0.125turn);
        }

        .drive {
          width: var(--width);
          height: calc(var(--width) * 1.4);
          border: 12px solid white;
          border-radius: 4px;
          position: relative;
          background: radial-gradient(
              circle at 50% 40%,
              transparent,
              transparent 5%,
              white 5%,
              white 10%,
              #f7df1e 10%,
              grey 50%,
              white 50%,
              white calc(50% + 1px),
              transparent 20%
            ),
            radial-gradient(
              circle at 30% 75%,
              #334 20%,
              white calc(20% + 4px),
              transparent calc(20% + 4px)
            );
        }
        .drive .arm {
          --arm-height: calc(var(--width) * 0.5);
          height: --arm-height;
          border: 8px solid transparent;
          border-bottom: white solid var(--arm-height);
          box-sizing: border-box;
          width: 8px;
          position: absolute;
          bottom: 20%;
          left: calc(30% - 8px);
          transform-origin: bottom;
          transform: rotate(0.1turn);
          animation: read-drive 2s infinite alternate linear;
          animation-play-state: paused;
        }
        @keyframes read-drive {
          from {
            transform: rotate(0.09turn);
          }
          to {
            transform: rotate(0.18turn);
          }
        }

        .promise {
          width: var(--width);
          height: var(--width);
          background-color: #f7df1e;
          position: relative;
        }
        .promise::after {
          content: "then";
          position: absolute;
          right: 5px;
          bottom: 5px;
          color: black;
          font-size: 2em;
        }

        .animation {
          width: var(--width);
          height: var(--width);
          background-image: url("css/cat.png");
          background-size: contain;
        }
        .animation.running {
          background-image: url("css/cat.gif");
        }

        .immediate::after {
          content: "!";
          font-weight: bold;
          color: white;
          font-size: 4em;
          padding: 0 10px;
          font-family: serif;
        }

        .next-tick {
          width: var(--width);
          height: var(--width);
          display: flex;
          border-radius: 50%;
        }

        .next-tick::after {
          content: "";
          display: block;
          border: 10px solid green;
          width: calc(var(--width) * 0.6);
          height: calc(var(--width) * 0.3);
          border-top-style: none;
          border-right-style: none;
          transform: rotate(-0.125turn);
          margin: auto;
        }

        .postmessage {
          width: var(--width);
          height: calc(var(--width) / 1.4);
          margin-top: calc(var(--width) * 0.3);
          border: 4px solid white;
          position: relative;
        }

        .postmessage::after {
          content: "";
          display: block;
          border: inherit;
          width: calc(var(--width) / 1.41 - 1.5px);
          height: calc(var(--width) / 1.41 - 1.5px);
          transform-origin: top left;
          transform: rotate(-0.125turn);
          position: absolute;
          left: -2.5px;
          top: -0.5px;
          border-top: transparent;
          border-right: transparent;
          border-bottom-left-radius: 5px;
        }
      </style>
      <div class="container"></div>
    </template>
    <script>
      const taskSourceDocument = document.currentScript.ownerDocument
      class TaskSource extends HTMLElement {
        constructor() {
          super()

          this.shadow = this.attachShadow({ mode: "closed" })
          const content = taskSourceDocument
            .getElementById("task-source")
            .content.cloneNode(true)
          this.shadow.appendChild(content)

          this.type = this.attributes.type.value
          this.container = this.shadow.querySelector(".container")

          this.source = document.createElement("div")
          this.source.classList.add(this.type)
          this.container.appendChild(this.source)

          this.thread = document.createElement("div")
          this.thread.classList.add("thread")
          this.container.appendChild(this.thread)

          if (this.type === "drive") {
            this.arm = document.createElement("div")
            this.arm.classList.add("arm")
            this.source.appendChild(this.arm)
          }
        }

        connectedCallback() {
          const syncTasks = [
            "html",
            "browser",
            "promise",
            "animation",
            "immediate",
            "next-tick",
            "postmessage",
          ]
          const asyncTasks = ["timer", "network", "drive"]
          if (asyncTasks.includes(this.type)) {
            this.source.addEventListener("click", () => {
              this.startAsyncTask()
            })
          } else if (this.source) {
            this.container.addEventListener("click", () => {
              this.addTask()
            })
          }

          document.body.addEventListener(
            "keydown",
            (event) => {
              if (event.key === "PageDown") {
                location.href = "/#/7"
              }
            },
            { once: true }
          )
        }

        startAsyncTask() {
          const task = document.createElement("div")
          task.classList.add("thread-item")
          this.thread.appendChild(task)

          const shrinker = document.createElement("div")
          shrinker.classList.add("shrinker")
          task.appendChild(shrinker)

          const asyncTask = document.createElement("div")
          asyncTask.classList.add(this.type)
          shrinker.appendChild(asyncTask)

          requestAnimationFrame(() => asyncTask.classList.add("go"))

          if (this.type === "timer") {
            asyncTask.style.transitionDuration = `${this.getRandomTime()}ms`
            asyncTask.addEventListener("transitionend", () => {
              this.addTask()
              task.remove()
            })
          } else if (this.type === "drive") {
            const isPlaying = this.arm.style.animationPlayState === "running"

            if (!isPlaying) {
              this.arm.style.animationPlayState = "running"
              this.finishDriveTask(task)
            }
          } else {
            this.finishTask(task)
          }
        }

        finishTask(task, time = this.getRandomTime()) {
          setTimeout(() => {
            this.addTask()
            task.remove()
          }, time)
        }

        finishDriveTask(task) {
          setTimeout(() => {
            this.finishTask(task, 0)

            const driveTasks = this.shadow.querySelectorAll(
              ".drive + .thread .thread-item"
            )
            if (driveTasks.length > 1) {
              const nextTask = driveTasks[1]
              this.finishDriveTask(nextTask)
            } else {
              this.arm.style.animationPlayState = "paused"
            }
          }, this.getRandomTime())
        }

        getRandomTime() {
          return Math.random() * 7000 + 3000
        }

        addTask() {
          const type = this.type === "promise" ? "microtask" : this.type
          document.body.dispatchEvent(new CustomEvent("task", { detail: type }))
        }

        run() {
          this.source.classList.add("running")
        }
        stop() {
          this.source.classList.remove("running")
        }

        hasTasksWaiting() {
          if (this.thread) {
            return !!this.thread.children.length
          }
        }
      }
      customElements.define("task-source", TaskSource)
    </script>

    <template id="pipeline">
      <style>
        :host {
          display: flex;
          flex-direction: column;
          margin-top: 5vh;
        }

        browser-window {
          height: 30vh;
          width: 95%;
          margin: auto;
          z-index: -1;
        }

        browser-window.go {
          transition: transform 2s 0.5s linear;
          transform: translateY(103%);
        }

        .pipe {
          --lightgreen: #16cc16;
          --midgreen: #28a828;
          width: 16vh;
          max-width: 100%;
          height: 33vh;
          border: 6px solid #006000;
          background: linear-gradient(
            to right,
            green,
            green 12%,
            var(--midgreen) 12%,
            var(--midgreen) 15%,
            green 15%,
            green 17%,
            var(--midgreen) 17%,
            var(--midgreen) 60%,
            var(--lightgreen) 60%,
            var(--lightgreen) 81%,
            var(--midgreen) 81%,
            var(--midgreen) 86%,
            var(--lightgreen) 86%,
            var(--lightgreen) 93%,
            var(--midgreen) 93%
          );
          box-sizing: border-box;
          position: relative;
        }
        .pipe::before {
          content: "";
          display: block;
          height: 25%;
          position: absolute;
          border: inherit;
          left: calc(-2vw - 6px);
          right: calc(-2vw - 6px);
          top: -6px;
          background: inherit;
        }

        .timer {
          font-size: 3em;
          position: absolute;
          bottom: 0;
          right: 0;
        }
        .overtime {
          color: red;
        }
      </style>
      <browser-window class="go">
        <button>CLICK ME</button>
      </browser-window>
      <div class="pipe"></div>
      <div class="timer" id="seconds-since-repaint"></div>
    </template>
    <script>
      const pipelineDocument = document.currentScript.ownerDocument
      class RenderingPipeline extends HTMLElement {
        constructor() {
          super()

          this.shadow = this.attachShadow({ mode: "open" })
          const content = pipelineDocument
            .getElementById("pipeline")
            .content.cloneNode(true)
          this.shadow.appendChild(content)

          this.browser = this.shadow.querySelector("browser-window")
          this.timer = this.shadow.getElementById("seconds-since-repaint")
          this.secondsSinceRepaint = 0

          this.browser.addEventListener("transitionend", (event) => {
            this.resolveTask()
            // this.startTimer()
          })
        }

        startTimer() {
          this.interval = setInterval(() => {
            this.timer.innerHTML = ++this.secondsSinceRepaint
            if (this.secondsSinceRepaint > 16) {
              this.timer.classList.add("overtime")
            } else {
              this.timer.classList.remove("overtime")
            }
          }, 500)
        }

        runTask() {
          const taskPromise = new Promise(
            (resolve) => (this.resolveTask = resolve)
          )

          this.secondsSinceRepaint = 0
          clearInterval(this.interval)

          requestAnimationFrame(() => {
            this.browser.classList.remove("go")

            requestAnimationFrame(() => {
              this.browser.classList.add("go")
            })
          })

          return taskPromise
        }
      }
      customElements.define("rendering-pipeline", RenderingPipeline)
    </script>

    <template id="browser">
      <style>
        :host {
          display: flex;
          --control-colour: #aaa;
          --control-highlight: #ccc;
          --control-shadow: #888;
        }
        .chrome {
          width: 100%;
          height: 100%;
          border: 2px solid var(--control-colour);
          border-left: 4px ridge var(--control-colour);
          position: relative;
          display: flex;
          flex-direction: column;
          background-color: white;
        }
        .chrome::before {
          content: "";
          width: calc(100% + 3px);
          height: calc(100% + 3px);
          border: 2px solid;
          left: -4px;
          top: -4px;
          border-color: var(--control-highlight);
          border-right-color: var(--control-shadow);
          position: absolute;
          z-index: -1;
        }
        .titlebar {
          height: 20px;
          margin: -3px -2px -2px -2px;
          border-bottom: 4px ridge #aaa;
          background-color: #aaa;
          position: relative;
          display: flex;
          flex: 0 0 auto;
        }
        .page {
          flex-grow: 1;
          padding: 5px;
          display: flex;
        }

        .window-control {
          --box-shadow-1: 0 -1px 0 1px;
          --box-shadow-2: 0 2px 2px;
          --box-shadow-3: 0 2px rgba(255, 255, 255, 0.25) inset;
          cursor: pointer;
          background: #e53030;
          box-shadow: var(--box-shadow-1) #c91919 inset,
            var(--box-shadow-2) rgba(65, 8, 8, 0.17), var(--box-shadow-3);
          width: 10px;
          height: 10px;
          border-radius: 50%;
          margin: 5px 2px;
          border: 1px solid #666;
          flex-shrink: 0;
        }
        .window-control:nth-child(2) {
          background: #ffc334;
          box-shadow: var(--box-shadow-1) #ffb401 inset,
            var(--box-shadow-2) rgba(103, 73, 0, 0.17), var(--box-shadow-3);
        }
        .window-control:last-child {
          background: #0ec518;
          box-shadow: var(--box-shadow-1) #0b9512 inset,
            var(--box-shadow-2) rgba(0, 7, 1, 0.17), var(--box-shadow-3);
        }

        button {
          cursor: pointer;
          background: hsl(215, 100%, 50%);
          color: white;
          border: 1px solid #666;
          border-radius: 2px;
          box-shadow: 2px 2px 4px #ccc, 0 -2px 2px hsl(215, 80%, 38%) inset,
            0 2px 2px hsl(215, 80%, 80%) inset;
          width: 80%;
          margin: auto;
          padding: 5px;
        }
        button:active {
          outline: none;
          box-shadow: 0 -2px 2px hsl(215, 80%, 80%) inset,
            0 2px 2px hsl(215, 80%, 38%) inset;
        }
        button:focus {
          outline: none;
        }
      </style>
      <div class="chrome">
        <div class="titlebar">
          <div class="window-control"></div>
          <div class="window-control"></div>
          <div class="window-control"></div>
        </div>
        <div class="page"><button>Click Me</button></div>
      </div>
    </template>
    <script>
      const browserDocument = document.currentScript.ownerDocument
      class Browser extends HTMLElement {
        constructor() {
          super()

          const shadow = this.attachShadow({ mode: "closed" })
          const content = browserDocument
            .getElementById("browser")
            .content.cloneNode(true)
          shadow.appendChild(content)

          this.button = shadow.querySelector("button")
          this.button.addEventListener("click", () => {
            document.body.dispatchEvent(
              new CustomEvent("task", { detail: "browser" })
            )
          })
        }
      }
      customElements.define("browser-window", Browser)
    </script>

    <template id="queue">
      <style>
        :host {
          display: block;
          width: var(--queue-width);
          height: calc(var(--queue-width) * 0.5);
          position: relative;
          border: 16px solid var(--container-colour);
          border-top-color: transparent;
          align-self: flex-end;
        }
        :host::before,
        :host::after {
          content: "";
          --curl-width: calc(var(--queue-width) / 4);
          width: var(--curl-width);
          height: var(--curl-width);
          display: block;
          border: 16px solid var(--container-colour);
          border-radius: 50%;
          border-bottom-color: transparent;
          border-right-color: transparent;
          transform: translateY(16px) rotate(0.125turn);
          position: absolute;
          bottom: calc(100% - 1vw - 4px);
        }
        :host::before {
          right: 100%;
        }
        :host::after {
          left: 100%;
        }

        .task {
          width: calc(var(--queue-width) * 0.8);
          height: var(--queue-width);
          background-color: white;
          border: 4px solid black;
          flex-shrink: 0;
          display: flex;
          transition: left 0.5s linear, bottom 0.5s linear, height 3s linear;
          position: absolute;
          right: 0;
          bottom: 0;
          overflow: hidden;
          color: black;
        }
        .task::before {
          margin: auto;
          content: "{}";
          font-family: "Courier New", Courier, monospace;
          font-weight: bold;
          overflow: hidden;
          font-size: 3em;
        }

        .task.browser {
          background-color: hsl(215, 80%, 80%);
        }
        .task.timer {
          background-color: hsl(350, 80%, 80%);
        }
        .task.network {
          background-color: hsl(100, 80%, 80%);
        }
        .task.drive {
          background-color: hsl(40, 80%, 80%);
        }
        .task.microtask {
          background-color: #f7df1e;
        }
        .task.next-tick {
          color: white;
          border-color: white;
          background-color: red;
        }
        .task.necessary {
          background-color: rgb(var(--green));
        }
        .task.unnecessary {
          border-color: #aaa;
        }

        .task.animation {
          height: 60px;
          background-image: url("css/cat.png");
          background-size: cover;
        }
        .task.animation::before {
          content: "";
        }
      </style>
      <div class="tasks"></div>
    </template>
    <script>
      const queueDocument = document.currentScript.ownerDocument
      class TaskQueue extends HTMLElement {
        constructor() {
          super()

          this.shadow = this.attachShadow({ mode: "closed" })
          const content = queueDocument
            .getElementById("queue")
            .content.cloneNode(true)
          this.shadow.appendChild(content)

          this.tasks = this.shadow.querySelector(".tasks")

          const typeAttribute = this.attributes.type
          this.type = typeAttribute ? typeAttribute.value : "default"

          const colour = this.getColour(this.type)
          this.style.setProperty("--container-colour", colour)

          const shadowColour = this.getShadowColour(this.type)
          this.style.setProperty("--shadow-colour", shadowColour)

          this.addEventListener("do-task", this.runTask)
        }

        getColour(queueType) {
          switch (queueType) {
            case "microtask":
              return "#f7df1e"
            case "next-tick":
              return "green"
            case "animation":
              return "#28a828"
            default:
              return "orange"
          }
        }

        getShadowColour(queueType) {
          if (queueType === "animation" || queueType === "next-tick") {
            return "#006000"
          }

          return "#93510b"
        }

        addTask(taskType) {
          const task = document.createElement("div")
          task.classList.add("task")
          task.classList.add(taskType)

          const index = this.getTasks().length
          this.positionTask(task, index)

          this.tasks.appendChild(task)
        }

        getTasks() {
          return this.shadow.querySelectorAll(".task")
        }
        getTask(index) {
          return this.getTasks()[index]
        }
        hasTasks() {
          return this.getTasks().length
        }

        async runTask(time) {
          if (this.type === "animation") {
            return this.runAnimationTasks()
          }

          const firstTask = this.getTask(0)
          if (firstTask) {
            let duration = time || this.getRandomTime()
            if (firstTask.classList.contains("repeating")) {
              this.addTask("repeating")
              duration = 2
            }
            await this.startTask(firstTask, duration)
          }
        }

        startTask(task, duration) {
          let resolveTask
          const taskPromise = new Promise((resolve) => (resolveTask = resolve))

          task.style.transitionDuration = `.5s, .5s, ${duration}s`
          task.style.height = 0

          task.addEventListener("transitionend", (event) => {
            if (event.propertyName === "height") {
              task.remove()
              this.redrawTasks()
              resolveTask()
            }
          })

          return taskPromise
        }

        async runAnimationTasks() {
          const animationSource = document.querySelector(
            'task-source[type="animation"]'
          )
          animationSource.run()
          const currentTasks = this.getTasks()
          currentTasks.forEach((task) => (task.style.borderColor = "white"))
          for (let task of currentTasks) {
            await this.startTask(task)
          }
          animationSource.stop()
        }

        redrawTasks() {
          const tasks = this.getTasks()
          tasks.forEach(this.positionTask)
        }

        positionTask(task, index) {
          task.style.right = `${index * 8}px`
          task.style.bottom = `${index * 8}px`
          task.style.zIndex = index * -1
        }

        getRandomTime() {
          return Math.random() * 4 + 2
        }
      }
      customElements.define("task-queue", TaskQueue)
    </script>
  </body>
</html>
