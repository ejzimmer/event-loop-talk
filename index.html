<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Further Adventures of the Event Loop</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/loops.css">
		<link rel="stylesheet" href="css/common.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<div class="mask">
						<svg class="title" viewBox="0 0 100 50" style="width: 80%">
							<path id="curve" d="M 10 50 a 40 40 0 0 1 80 0" fill="transparent" />
							<text font-family="cursive">
								<textPath font-size=".5em" textLength="125" xlink:href="#curve">
									Further Adventures of
								</textPath>
							</text>
						</svg>
					</div>
					<h1>The Event Loop</h1>
					<div class="twitter">@erinjzimmer</div>
				</section>
				<section>
					<h2>What actually is the Event Loop?</h2>
					<div class="notes">
						To understand what the event loop is, first it might be helpful to understand what it is not.
					</div>
				</section>
				<section class="full-height">
					<fieldset class="browser-internals">
						<legend>The Browser</legend>
						<div class="browser-bits">
							<img id="engine" src="css/JavaScript-logo.png" class="fragment" style="margin-left: 0" />
							<task-source type="network" class="fragment"></task-source>
							<task-source type="timer" class="fragment"></task-source>
							<task-source type="drive" class="fragment"></task-source>
							<img src="css/mouse-pointer.svg" class="fragment" style="margin: .75em" />
							<div class="html fragment"></div>
							<div id="web-apis" style="animation: unset">Web APIs</div>
						</div>
					</fieldset>
					<div class="notes">
						- You see, browsers have a bunch of different bits in them
						- One is the bit that runs from JavaScript
						- But there's also another bit that takes care of network requests
						- And a bit that looks after timers
						- A bit that can do disk I/O
						- A bit that listens for user interactions
						- And a heap of bits that interact with the DOM and CSS.
						- Collectively, these bits that aren't the bit that runs JavaScript are called...
						- ... Web APIs. The event loop isn't a web API.
					</div>
					<script>
						document.querySelector('.browser-internals').addEventListener('click', function () {
							this.classList.add('web-apis');
							this.addEventListener('click', () => {
								document.querySelector('#web-apis').style.opacity = 1;
							}, { once: true });
						}, { once: true });
					</script>
				</section>
				<section>
					<span style="position: relative">
						<img src="css/libuv.svg" style="width: calc(80vmin - 80px)" />
						<div class="libuv">libuv</div>
					</span>
					<div class="notes">
						Node equivalent == unicorn velocity library.
						Because of course it is.
						The event loop also isn't libuv.
					</div>
				</section>
				<section>
					<fieldset class="browser-internals engine">
						<legend>The Browser</legend>
						<div class="browser-bits">
							<img id="engine" src="css/JavaScript-logo.png" style="margin-left: 0" />
							<task-source type="network"></task-source>
							<task-source type="timer"></task-source>
							<task-source type="drive"></task-source>
							<img src="css/mouse-pointer.svg" style="margin: .75em" />
							<div class="html"></div>
							<div id="engines" style="animation: unset">JavaScript Engine</div>
						</div>
					</fieldset>
					<script>
						document.querySelector('.browser-internals.engine').addEventListener('click', function () {
							this.querySelector('#engine').classList.add('highlighted');
							this.addEventListener('click', () => {
								document.getElementById('engines').style.opacity = 1;
							})
						}, { once: true });
					</script>
					<div class="notes">
						The bit that runs JavaScript is called the JavaScript engine.
					</div>
				</section>
				<section>
					<div class="engine-logos">
						<img class="fragment" src="css/v8-logo.png" />
						<img class="fragment" src="css/edge-logo.png" style="transform: scale(.6)" />
						<img class="fragment" src="css/squirrelfish.png" />
					</div>
					<img class="fragment" src="css/spider-monkey.jpg" style="width: 80%" />
					<div class="notes">
						There are a bunch of different JS engines kicking around
						- V8, in Chrome and Node
						- Chakra which powers Edge
						- er, Safari's SquirrelFish
						- and SpiderMonkey from Mozilla, which I couldn't find a logo for,
						so here's a picture of an actual SpiderMonkey
						spider monkey photo from Ewa https://www.flickr.com/photos/ewas-world/
						The event loop lives in JavaScript engines.
					</div>
				</section>
				<section>
					<pre><code data-noescape class="js" style="font-size: 4em">
while (true) {
 <span class="variable-name">task</span> = taskQueue.pop();
 execute(<span class="variable-name">task</span>);
}
					</code></pre>
					<div class="notes">
						The main function of the JS engine
						In its simplest form, would look something like this
						Now, while I'm sure we all understand how the loop part works, I think
						this code snippet probably raises a couple of other questions, like...
					</div>
				</section>
				<section>
					<div class="list-and-image">
						<ul>
							<li class="fragment">What's a task?</li>
							<li class="fragment">What's a task&nbsp;queue?</li>
						</ul>
						<img src="css/Philosoraptor.jpg" />
					</div>
					<div class="notes">
						What is a task? And what could it possibly be queueing up for?
					</div>
				</section>
				<section>
					<div class="columns">
					<pre><code>
<script>
 const intrepidAdventurers = [
  'Little Foot',
  'Cera',
  'Ducky',
  'Petrie',
  'Spike'
 ];

 function rawr() {
  console.log('rawr!')
 }

 intrepidAdventurers.forEach(rawr);
</script>
					</code></pre>
<div class="arrow-right fragment" data-fragment-index="1">^</div>
<div class="task fragment" data-fragment-index="1"></div>
</div>
<a class="demo-link" href="parser-only.html">Demo</a>
				</section>
				<section>
					<h2><div style="font-size: .9em">JavaScript, why are you like that?</div></h2>
					<div class="notes">
						The answer is due to two things
					</div>
				</section>
				<section>
					<h2>JavaScript is single-threaded</h2>
					<div class="notes">
						- This is a thing most people probably know
						- Important because DOM
						- So each task runs to completion before another task can start
						- But remember, the JS engine is only one part of the browser
					</div>
				</section>
				<section>
					<h2><i>Browsers</i> are multi-threaded</h2>
					<div class="notes">
						As well as running your JavaScript, a browser could be 
						- keeping track of mouse and keyboard events
						- making network requests
						- handling timers
						- disk operations 
						And any of these things could be generating tasks, via callbacks
					</div>
				</section>
				<section>
					<fieldset class="browser-internals">
							<legend>The Browser</legend>
							<div class="browser-bits">
								<img id="engine" src="css/JavaScript-logo.png" style="margin-left: 0" />
								<task-source type="network"></task-source>
								<task-source type="timer"></task-source>
								<task-source type="drive"></task-source>
								<img src="css/mouse-pointer.svg" style="margin: .75em" />
								<div class="html"></div>
								<div id="engines" style="animation: unset">JavaScript Engine</div>
							</div>
						</fieldset>						
				</section>
				<section>
					<div class="columns">
						<pre class="script-task"><code data-noescape>const btn = document.createElement('button');
document.body.appendChild(btn);

btn.addEventListener('click', function () {
 <span class="click-task">console.log('CHOMP!');</span>
});</code></pre>
						<div class="vertical">
							<div class="task" style="background-color: rgb(var(--pink))"></div>
							<div class="task" style="background-color: rgb(var(--green))"></div>
						</div>
					</div>
					<a class="demo-link" href="simple.html">Demo</a>
				<script>
					document.body.addEventListener('click', () => {
						document.querySelector('.script-task').classList.add('highlighted');
						document.querySelector('.vertical .task').style.opacity = 1;

						document.body.addEventListener('click', () => {
							document.querySelector('.click-task').classList.add('highlighted');
							document.querySelector('.vertical .task:nth-child(2)').style.opacity = 2;
						}, { once: true });
					}, { once: true });
				</script>
				</section>
				<section>
					<pre><code data-noescape class="js" style="font-size: 4em">
while (true) {
 <span class="variable-name">task</span> = taskQueue.pop();
 execute(<span class="variable-name">task</span>);
}
					</code></pre>
					<div class="notes">
						So that's basically how tasks and task queues work.
						Of course, in real life, it's a bit more complicated than that
					</div>
				</section>
				<section data-background-image="css/mario.jpg">
					<a class="heading" href="rendering-pipeline.html">The Rendering Pipeline</a>
				</section>
				<section class="center">
					<img src="css/unco-cat.gif" class="stretch border" />
					<div class="notes">
						Long running tasks will cause your browser to start dropping frames
						and, much like this cat, your app just won't run right
					</div>
				</section>
				<section class="center">
					<pre><code style="font-size: 3em">
function repeat(reps, action) {
 const batchSize = Math.min(reps, 1000);
 for (let i = 0; i < batchSize; i++) {
  action();
 }

 const repsLeft = reps - batchSize;
 if (repsLeft) {
  setTimeout(() => {
   repeat(repsLeft, action)
  });
 }
}
					</code></pre>
				</section>
				<section>
					<pre><code style="font-size: 3em" class="js">
const worker = new Worker('job.js');
					</code></pre>
					<div class="fragment" style="font-size: 8em; text-align: center">🎉</div>
					<div class="notes">
						Or you could use a webworker, which is guaranteed not to interfere with your rendering
						for reasons we'll get into a bit later.
					</div>
				</section>
				<section>
						<pre><code data-noescape class="js" style="font-size: 3.7em">
while (true) {
 <span class="variable-name">task</span> = taskQueue.pop();
 execute(<span class="variable-name">task</span>);

 if (isRepaintTime()) repaint();
}
					</code></pre>
				</section>
				<section>
					<div class="spec-text" style="font-size: 2.5em">An <u>event loop</u> has one or more <b>task queues.</b></div>
				</section>
				<section>
						<pre><code>
bool did_work = delegate->DoWork();
if (!keep_running_)
	break;
did_work |= delegate->DoDelayedWork(&delayed_work_time_);
if (!keep_running_)
	break;
if (did_work)
	continue;
did_work = delegate->DoIdleWork();
if (!keep_running_)
	break;
					</code></pre>
				</section>
				<section>
					<a style="font-size: 2.5em;" href="multiple-queues.html">Theoretical browser with multiple task queues</a>
				</section>
				<section>
					<div class="list-container" style="font-size: 1.5em">
						<ul>
							<li class="fragment">Queues can be executed in any order</li>
							<li class="fragment">Tasks in the same queue must be executed in the order they arrived</li>
							<li class="fragment">Tasks from the same source<br> must go in the same queue</li>
						</ul>
					</div>
				</section>
				<section>
						<pre><code data-noescape class="js" style="font-size: 3.7em">
while (true) {
 <span class="variable-name">queue</span> = getNextQueue();
 <span class="variable-name">task</span> = <span class="variable-name">queue</span>.pop();
 execute(<span class="variable-name">task</span>);

 if (isRepaintTime()) repaint();
}
					</code></pre>
				</section>
				<section data-background-image="css/littlefoot-and-mum.jpg">
					<h2 class="heading-card" style="position: relative; top: 20px"><a href="microtasks.html">Microtasks</a></h2>
				</section>
				<section data-background-image="css/dinos-fightin.jpg">
					<div style="display: flex">
						<h2 class="heading-card" style="display: block; margin: auto">
							<a href="infinite-timeouts.html">Tasks</a>
							<div style="margin: 10px">vs</div>
							<a href="infinite-promises.html" target="_blank" rel="noopener">Microtasks</a>
						</h2>
					</div>
					<a class="demo-link" href="microtasks.html">Demo</a>
				</section>
				<section>
					<pre><code data-noescape class="js" style="font-size: 3.5em">
while (true) {
 <span class="variable-name">queue</span> = getNextQueue();
 <span class="variable-name">task</span> = <span class="variable-name">queue</span>.pop();
 execute(<span class="variable-name">task</span>);

 while (<span class="variable-name">microtaskQueue</span>.hasTasks())
  doMicrotask();

 if (isRepaintTime()) repaint();
}
					</code></pre>
				</section>
				<section data-background-image="css/ducky-walking.gif">
					<h2 class="heading-card reverse" style="display: block">Animation Frame Callback Queue</h2>
				</section>
				<section>
					<pre><code style="text-align: center; font-size: 3.7em;">
requestAnimationFrame(callback);
					</code></pre>
				</section>
				<section>
					make a dinosaur themed animation demo
					show what happens with no requestAnimationFrame
					both frames end up in the same render phase, so the animation doesn't work
					we need a way to ensure the first line executes, then the screen repaints,
					then the second line executes
					show demo
					so if we change our code to use requestAnimationFrame like so 
					(remember we need two calls to requestAnimationFrame, else both lines 
					could still end up in the same loop)
					now it works!
				</section>
				<section>
					<pre><code class="javascript" style="font-size: 3em">
requestAnimationFrame(() => {
  this.browser.classList.remove('slide');

  requestAnimationFrame(() => {
    this.browser.classList.add('slide');
  });
});				
					</code></pre>
				</section>
				<section>
					<pre><code class="javascript" style="font-size: 3em">
this.browser.classList.remove('slide');
this.browser.classList.add('slide');					
					</code></pre>
					<img style="filter: drop-shadow(2px 2px 1px var(--background-start));" src="css/Clippy.png" />
					<a class="demo-link" style="left: 0; right: unset" href="requestAnimationFrame.html">Demo</a>
				</section>
				<section>
						<pre><code data-noescape class="js" style="font-size: 2.6em">
while (true) {
 <span class="variable-name">queue</span> = getNextQueue();
 <span class="variable-name">task</span> = <span class="variable-name">queue</span>.pop();
 execute(<span class="variable-name">task</span>);

 while (<span class="variable-name">microtaskQueue</span>.hasTasks()) 
  doMicrotask();

 if (isRepaintTime()) {
  <span class="variable-name">animationTasks</span> = <span class="variable-name">animationQueue</span>.copyTasks();
  for (<span class="variable-name">task</span> in <span class="variable-name">animationTasks</span>) 
   doAnimationTask(<span class="variable-name">task</span>);
		
  repaint();
 }
}
					</code></pre>
				</section>
				<section>
					<h2 style="text-align: left">Why don't web workers interfere with rendering?</h2>
					<div class="notes">
						You all remember when we were talking about long-running tasks and I said you could
						use web workers, because they were guaranteed not to interfere with the rendering pipeline?
						So, given everything we now know about how the event loop works in browsers, how can I be so sure?
						Because I read the spec...
					</div>
				</section>
				<section data-transition="fade-out" style="transition-duration: 5s">
					<div class="spec-text">
						Each <b><i>WorkerGlobalScope</i></b> object has a distinct <u>event loop</u>, 
						separate from those used by <u>units of related similar-origin browsing contexts</u>.
					</div>
				</section>
				<section data-transition="fade-in" style="transition-duration: 5s">
					<div style="font-size: 3.3em">Each web worker has its own event loop.</div>
					<a class="demo-link" href="browser-worker.html">Demo</a>
				</section>
				<section>
					<div class="spec-text">
						This event loop has no associated browsing context, and its task queues only have events, callbacks, and networking activity as tasks.
					</div>
				</section>
				<section>
					<div class="list-and-image">
						<ul>
							<li class="fragment">No user interactions</li>
							<li class="fragment">No rendering pipeline</li>
							<li class="fragment">No DOM at all!</li>
						</ul>
						<img src="css/top-hat-t-rex.gif" class="fragment" />
				</section>
				<section>
					<div class="communication">
						<fieldset class="worker">
							<legend>Worker</legend>
							<button id="rawr-button">Send Message</button>
							<pre><code style="padding: 0">postMessage('rawr!');</code></pre>
						</fieldset>
						<fieldset>
							<legend>Browser</legend>
							<pre><code><script style="display: block">
const myWorker = new Worker('worker.js');
myWorker.addEventListener('message', 
function (message) {
 response.innerHTML = message.data;
});
</script>
</code></pre>
							<div id="response"></div>
						</fieldset>
					</div>
					<script>
						const rawrButton = document.getElementById('rawr-button');
						rawrButton.addEventListener('click', () => {
							myWorker.postMessage('hello');
						});	
						const response = document.getElementById('response');
					</script>
					<div class="notes">
						Segue - web workers aren't the time a browser might have multiple event loops
					</div>
				</section>
				<section>
					<img src="css/chrome-processes.png" class="stretch border" />
					<div class="notes">
						If you've ever had a look at your Activity Monitor or Task Manager while Chrome is running,
						you probably saw something like this...
						Chrome likes to run things in lots of different processes. 
						If you have a look at the Chrome Task Manager, you can see what each of those processes is actually doing.
						(Do it)
						And you would see that you've got a process for each tab, each browser extension, and a couple of extras.
						The important thing here, is that we have a process for each tab.
						Because each of those tabs is running in a separate process, they must have their own event loop.
						This means that if we start some resource heavy process in one tab, none of the others are affected.
						This is a big advantage of this process per tab model.
						Each tab is isolated so it doesn't affect the security or performance of the other tabs.
					</div>
				</section>
				<section>
					<img src="css/firefox-processes.png" class="stretch border" />
					<div class="notes">
						It doesn't have to be this way though. If you open all the same tabs in Firefox and check out the task 
						manager, you see something like this: just four processes for all of your tabs.
						This has some disadvantages - demo of bad tab slowing down other tabs
						The big advantage is that it leaves some RAM left over for running other applications
					</div>
				</section>










				<section>
					<img src="css/good-news-everyone.jpg" alt="" class="stretch border">
				</section>
				<section>
					<h2>No rendering pipeline!</h2>
					<div class="fragment" style="font-size: 8em">🎉</div>
					<a href="web-worker.html" class="demo-link">Demo</a>
				</section>
				<section>
					<div class="text">... but what about Node?</div>
				</section>
				<section>
					<img class="border full-page" src="css/good-news-everyone.jpg" />
				</section>
				<section>
					<div class="list-container" style="font-size: 2em;">
						<ul>
							<li class="fragment">No script parsing events</li>
							<li class="fragment">No pesky user interactions</li>
							<li class="fragment">No animation frame callbacks</li>
							<li class="fragment">No rendering pipeline <i>at all</i></li>
						</ul>
					</div>
				</section>
				<section>
					<img class="full-page" src="css/corgi-carousel.gif" />
				</section>
				<section>
					<img class="full-page" src="css/thunderbolt.gif" />
				</section>
				<section>
					<a class="text" href="node.html">Node event loop demo</a>
				</section>
				<section>
					<pre><code style="text-align: center; font-size: 4em" class="lisp">setImmediate(callback)</code></pre>
				</section>
				<section>
					<div style="display: flex; align-items: center; font-size: 2em">
						<pre><code>setTimeout(callback, 0)</code></pre>
						<img style="width: 20vmin" src="css/hedgehog.png" />
					</div>
					<div style="display: flex; align-items: center; font-size: 2em">
						<img style="width: 20vmin" src="css/sonic.png" />
						<pre><code>setImmediate(callback)</code></pre>
					</div>
					<a class="demo-link" href="node.html">Demo</a>
				</section>
				<section>
					<pre><code style="text-align: center; font-size: 4em" class="lisp">process.nextTick(callback)</code></pre>
					<a class="demo-link" href="node.html">Demo</a>
				</section>
				<section>
					<div style="display: flex">
						<pre><code style="font-size: 3em">setImmediate():</code></pre>
						<div style="padding: .5em; font-size: 2.2em; align-self: center">do something on the next tick</div>
					</div>
					<div style="display: flex;" class="fragment">
						<pre><code style="font-size: 3em">process.nextTick():</code></pre>
						<div style="padding: .5em; font-size: 2.2em; align-self: center">do something immediately</div>
					</div>
				</section>
				<section>
						<pre><code data-noescape class="js" style="font-size: 2.6em">
while (tasksAreWaiting()) {
 <span class="variable-name">queue</span> = getNextQueue();

 while (queue.hasTasks()) {
  <span class="variable-name">task</span> = <span class="variable-name">queue</span>.pop();
  execute(<span class="variable-name">task</span>);

  while (<span class="variable-name">nextTickQueue</span>.hasTasks()) 
   doNextTickTask();

  while (<span class="variable-name">promiseQueue</span>.hasTasks()) 
   doPromiseTask();
 }
}
					</code></pre>
				</section>
				<section>
					<div style="position: absolute; top: 50vh; font-size: 3em;">Web workers</div>
					<img src="css/redback.png" />
				</section>
				<section>
					... but what about multiple event loops?
				</section>
				<section>
				</section>
				<section>
					So the obvious situation where you might have multiple event loops is where you're
					running multiple web pages in the one browser, either in different tabs/windows, or
					in iFrames. Generally speaking, it's up to the browser to decide how many event 
					loops it wants to run in this situation.
					Check whether iframes run in same process or different
					Chrome spins up another event loop if you look at it sideways
					Each window/tab/iframe runs in its own thread/process, which is why you end up with your task manager full of Chrome processes. This approach makes Chrome more secure?
					Firefox takes a restrained approach, and will spin up up to four new processes
					(check this), each with their own event loop. Beyond that, new windows/tabs/iframes 
					share existing processes. This has the advantage of not requiring 16GB of RAM just to
					run your browser.
					I don't know what Safari and Edge do. I don't have a windows machine to test Edge on
					and Safari and I haven't been on speaking terms since an incident with flexbox in Safari 10.
					Some kind of demo. Maybe Firefox blocking up other windows while Chrome is fine.
					But then the flip side of how much memory Chrome is using vs Firefox.
				</section>
				<section>
					There is one rule though - pages that share data MUST share an event loop.
					iframes?
					parent/child window
				</section>
				<section>
					- how iframes work
					- how child windows work
					- how to allow them to be on separate event loops
				</section>
				<section>
					There is one other situation where multiple event loops are a thing - workers
					- web workers, service workers, whatever kind of worker Node has
					Workers run in parallel to the main thread, so they must have their own event loop
					As a result, they're completely separate from the main thread - no DOM access
					While a child window can access its parent directly, workers can only send and receive 
					postmessage events
				</section>
				<section>
						<div style="width: 45%; position: fixed; top: 5vh; left: 0; border: 4px solid red; padding: 5px">
							<div style="display: flex; flex-wrap: wrap; justify-content: space-between; margin: auto;">
								<div class="area" style="width: 40%; display: flex; flex-direction: column; justify-content: flex-end">
									<div style="flex-grow: 1">stack</div>
									<div class="task">setTimeout(cb)</div>
									<div class="task">main()</div>
								</div>
								<div class="area" style="width: 55%;">
									<div>webapis</div>
								</div>
								<div class="area" style="display: flex; width: 100%; margin-top: 1vw; height: 4em;">
									<div style="margin: auto 0;">task queue</div>
									<div class="task" style="margin-left: 5px">cb</div>
								</div>
							</div>
						</div>
						<div class="loading-dots" style="position: fixed; top: 30%; left: 45%; right: 25%;"></div>
						<div style="width: 25%; position: fixed; right: 0; top: 30%; border: 2px solid white; padding: 5px;">
							<div style="display: flex; flex-wrap: wrap; justify-content: space-between;">
								<div class="area" style="width: 40%; display: flex; flex-direction: column; justify-content: flex-end">
									<div style="flex-grow: 1">stack</div>
									<div class="task"></div>
									<div class="task"></div>
									<div class="task"></div>
								</div>
								<div class="area" style="width: 55%;">
									<div>webapis</div>
								</div>
								<div class="area" style="display: flex; width: 100%; margin-top: 1vw; height: 4em;">
									<div style="margin: auto 0;">task queue</div>
									<div class="task" style="margin-left: 5px">cb</div>
								</div>
							</div>
						</div>
						<div class="loading-dots" 
								style="position: fixed; top: 7em; left: 40%; transform: rotate(.25turn); transform-origin: left;">
						</div>
						<div style="width: 25%; position: fixed; left: 25%; bottom: 5vh; border: 2px solid white; padding: 5px;">
							<div style="display: flex; flex-wrap: wrap; justify-content: space-between;">
								<div class="area" style="width: 40%; display: flex; flex-direction: column; justify-content: flex-end">
									<div style="flex-grow: 1">stack</div>
									<div class="task"></div>
									<div class="task"></div>
									<div class="task"></div>
								</div>
								<div class="area" style="width: 55%;">
									<div>webapis</div>
								</div>
								<div class="area" style="display: flex; width: 100%; margin-top: 1vw; height: 4em;">
									<div style="margin: auto 0;">task queue</div>
									<div class="task" style="margin-left: 5px">cb</div>
								</div>
							</div>
						</div>
					</section>								
				</section>
				<section>
					<ul style="font-size: 4em">
						<li class="fragment">No script tags</li>
						<li class="fragment">No user interactions</li>
						<li class="fragment">No DOM manipulation</li>
					</ul>
					<a class="demo-link" href="web-worker.html">Demo</a>
				</section>
				<section>
					<img class="full-page" src="css/thats-it-too-easy.jpg" />
				</section>
				<section>
					<div style="font-size: 3.9em;">Long running tasks will make your web page run like a wonky cat</div>
				</section>
				<section>
					<div style="font-size: 4em">Promises and nextTick tasks can make it run like a dead cat</div>
				</section>
				<section>
					<div style="font-size: 4em">Node is a bit different</div>
				</section>
				<section>
					<div style="font-size: 4em">Web workers do their own thing</div>
				</section>
				<section>
					<div style="font-size: 3.5em;">The event loop is more exciting than you could possibly have imagined</div>
				</section>
				<section data-background-image="css/roller-coaster.jpg">
					<div class="frosted">
						<div style="margin-bottom: .5em">@erinjzimmer</div>
						<a href="/package.json" style="color: currentColor; font-size: .9em">https://ejzimmer.github.io/event-loop-talk</a>
					</div>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>
		
		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				controls: false,
				progress: false,
				history: true,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
				]
			});
		</script>

		<link rel="import" href="components/event-loop.html">
		<link rel="import" href="components/browser.html">
		<link rel="import" href="components/queues.html">
		<link rel="import" href="components/rendering-pipeline.html">
		<link rel="import" href="components/queue-selector.html">
		<link rel="import" href="components/queue.html">
    <link rel="import" href="components/task-source.html">
    
    <script>
      // const task = document.querySelector('.tasks');
      // task.addEventListener('click', function () {
      //   this.classList.add('highlighted');
      // });
      // document.body.addEventListener('keydown', (event) => {
      //   console.log(event.key);
      // });
		</script>
	</body>
</html>
